<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>问答生成</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script> <!-- 添加XLSX解析库 -->
    <!-- 配置 Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#2563eb',
                        neutral: '#f3f4f6',
                        accent: '#10b981',
                        warning: '#f59e0b',
                        danger: '#ef4444',
                        'primary-disabled': '#93C5FD', // 禁用状态的灰色调
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                    opacity: {
                        'disabled': '0.65', // 禁用元素的不透明度
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .shadow-hover {
                transition: all 0.3s ease;
            }
            .shadow-hover:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            }
            .select-wrapper {
                position: relative;
            }
            .select-wrapper::after {
                content: "\f078";
                font-family: "Font Awesome 6 Free";
                font-weight: 900;
                position: absolute;
                right: 15px;
                top: 50%;
                transform: translateY(-50%);
                pointer-events: none;
                color: #6b7280;
            }
            .date-input {
                @apply w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all text-lg; /* 增大字体 */
                height: 50px; /* 增大高度 */
            }
            .table-header {
                @apply px-6 py-4 text-left text-lg font-bold text-white uppercase tracking-wider bg-primary sticky top-0; /* 增大字体，设置为黑粗体，固定标题 */
            }
            .table-cell {
                @apply px-6 py-4 whitespace-normal break-words;
            }
            .session-link {
                @apply text-primary hover:text-secondary underline;
            }
            .input-error {
                @apply border-danger ring-1 ring-danger;
            }
            .error-message {
                @apply text-danger text-sm mt-1 flex items-center;
            }
            .status-indicator {
                @apply transition-all duration-500 ease-in-out;
            }
            /* 使表格出现滚动条 */
            #result-table-container {
                max-height: 400px; /* 设置最大高度 */
                overflow-y: auto; /* 垂直滚动条 */
            }
            /* 页面高度自适应 */
            body {
                min-height: 100vh;
                display: flex;
                flex-direction: column;
            }
            #main-content {
                flex: 1;
            }
            /* 新增进度条样式 */
            #progress-container {
                height: 4px;
                border-radius: 2px;
                background-color: #f3f4f6;
                margin: 1rem 0;
            }
            #progress-bar {
                height: 100%;
                background-color: #3b82f6;
                transition: width 0.3s ease;
            }
            /* 生成要求输入框样式 */
            .requirements-box {
                margin-top: 1rem;
                border: 1px solid #d1d5db;
                border-radius: 0.375rem;
                padding: 1rem;
                background-color: #f9fafb;
            }
            .requirements-title {
                font-weight: 600;
                margin-bottom: 0.5rem;
                color: #1f2937;
            }
            .requirements-textarea {
                width: 100%;
                min-height: 180px;
                padding: 0.75rem;
                border: 1px solid #d1d5db;
                border-radius: 0.375rem;
                background-color: white;
                font-size: 0.9rem;
                line-height: 1.5;
                resize: vertical;
            }
        }
    </style>
</head>

<body class="bg-gray-50 min-h-screen font-inter">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="bg-white rounded-xl shadow-md p-6 mb-8 transform transition-all duration-300 hover:shadow-lg">
            <form id="qa-form">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    <div class="space-y-2">
                        <label for="file-upload" data-translate-key="uploadLabel" class="block text-sm font-medium text-gray-700">上传 PDF 文件</label>
                        <div class="relative">
                            <input type="file" id="file-upload" name="file-upload" accept=".pdf" multiple
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-3 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-primary file:text-white hover:file:bg-secondary cursor-pointer">
                        </div>
                    </div>
                    <div class="space-y-2">
                        <label for="document-language" data-translate-key="docLangLabel" class="block text-sm font-medium text-gray-700">文档语言</label>
                        <div class="select-wrapper">
                            <select id="document-language"
                                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all appearance-none bg-white">
                                <option value="English" data-translate-key="langOptionEn">英文</option>
                                <option value="Chinese Simplified" data-translate-key="langOptionZh">中文</option>
                            </select>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <label for="client-id" data-translate-key="tenantLabel" class="block text-sm font-medium text-gray-700">租户选择</label>
                        <div class="select-wrapper">
                            <select id="client-id"
                                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all appearance-none bg-white">
                                <option value="" data-translate-key="tenantPlaceholder">-- 请选择Client ID --</option>
                            </select>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <label for="business-select" data-translate-key="bizLabel" class="block text-sm font-medium text-gray-700">业务选择</label>
                        <div class="select-wrapper">
                            <select id="business-select"
                                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all appearance-none bg-white">
                                <option value="" data-translate-key="bizPlaceholder">-- 请选择业务 --</option>
                            </select>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <label for="product-select" data-translate-key="prodLabel" class="block text-sm font-medium text-gray-700">产品选择</label>
                        <div class="select-wrapper">
                            <select id="product-select"
                                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all appearance-none bg-white">
                                <option value="" data-translate-key="prodPlaceholder">-- 请先选择业务 --</option>
                            </select>
                        </div>
                    </div>

                    <!-- 任务类型选择 -->
                    <div class="space-y-2">
                        <label data-translate-key="taskTypeLabel" class="block text-sm font-medium text-gray-700">任务类型</label>
                        <div class="flex items-center space-x-4">
                            <input type="checkbox" id="task-type-a" value="a"
                                class="form-checkbox text-primary h-4 w-4">
                            <label for="task-type-a" data-translate-key="taskTypeA" class="text-sm font-medium text-gray-700">根据问题找答案 (a)</label>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <label data-translate-key="generationMethodLabel" class="block text-sm font-medium text-gray-700">Generation Method</label>
                        <div class="flex items-center space-x-4 pt-2">
                            <div class="flex items-center">
                                <input type="radio" id="method-page" name="generation-method" value="page" class="form-radio text-primary h-4 w-4" checked>
                                <label for="method-page" data-translate-key="methodPageLabel" class="ml-2 text-sm font-medium text-gray-700">By Page</label>
                            </div>
                            <div class="flex items-center">
                                <input type="radio" id="method-chunk" name="generation-method" value="chunk" class="form-radio text-primary h-4 w-4">
                                <label for="method-chunk" data-translate-key="methodChunkLabel" class="ml-2 text-sm font-medium text-gray-700">By Chunk</label>
                            </div>
                        </div>
                    </div>

                    <!-- 问题列表上传（仅任务类型a显示） -->
                    <div id="question-list-upload" class="space-y-2 hidden">
                        <label for="question-file" data-translate-key="questionListLabel" class="block text-sm font-medium text-gray-700">上传问题列表
                            (xlsx单列)</label>
                        <input type="file" id="question-file" name="question-file" accept=".xlsx" multiple
                            class="w-full text-sm text-gray-500 file:mr-4 file:py-3 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-primary file:text-white hover:file:bg-secondary cursor-pointer">
                    </div>

                    <div class="space-y-2">
                        <label data-translate-key="optionsLabel" class="block text-sm font-medium text-gray-700">操作选项</label>
                        <div class="flex items-center space-x-4">
                            <input type="checkbox" id="clear-history" value="true"
                                class="form-checkbox text-primary h-4 w-4">
                            <label for="clear-history" data-translate-key="clearHistoryLabel" class="text-sm font-medium text-gray-700">
                                生成前清除历史问答
                            </label>
                        </div>
                    </div>
                </div>

                <!-- 新增：生成要求输入框（操作选项后） -->
                <div id="requirements-box" class="requirements-box">
                    <div data-translate-key="reqTitle" class="requirements-title">问答生成要求</div>
                    <textarea id="generation-requirements" data-translate-key-placeholder="reqPlaceholder" class="requirements-textarea" placeholder="请输入生成要求"></textarea>
                </div>

                <div id="progress-container" class="hidden">
                    <div id="progress-bar" class="h-full bg-primary" style="width: 0%"></div>
                </div>
                <div id="progress-text" class="mt-2 text-sm text-gray-600"></div>
                <div id="progress-status" class="mt-1 text-sm text-gray-500"></div>

                <div class="flex flex-wrap gap-4">
                    <button type="button" id="create-button"
                        class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary transition-colors duration-300 flex items-center gap-2 shadow-hover">
                        <i class="fa-solid fa-database"></i> <span data-translate-key="createKbButton">创建知识库</span>
                    </button>

                    <button type="button" id="generate-button"
                        class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary transition-colors duration-300 flex items-center gap-2 shadow-hover">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> <span data-translate-key="generateButton">生成问答</span>
                    </button>
                    <button type="button" id="cancel-button"
                        class="px-6 py-3 bg-warning text-white rounded-lg hover:bg-warning/90 transition-colors duration-300 flex items-center gap-2 shadow-hover hidden">
                        <i class="fa-solid fa-stop"></i> <span data-translate-key="cancelButton">取消生成</span>
                    </button>
                    <button type="button" id="query-button"
                        class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary transition-colors duration-300 flex items-center gap-2 shadow-hover">
                        <i class="fa-solid fa-search"></i> <span data-translate-key="queryButton">查询问答</span>
                    </button>
                    <button type="button" id="export-csv-button"
                        class="px-6 py-3 bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors duration-300 flex items-center gap-2 shadow-hover">
                        <i class="fa-solid fa-file-csv"></i> <span data-translate-key="exportButton">导出为 CSV</span>
                    </button>
                </div>
            </form>
        </div>

        <!-- 状态区域 -->
        <div id="status" class="bg-neutral p-4 rounded-lg border border-gray-200 mb-6 flex items-center">
            <i class="fa-solid fa-clock-o mr-3 text-gray-500"></i>
            <span data-translate-key="statusWaiting">等待操作...</span>
        </div>

        <div id="result-table-container" class="bg-white rounded-xl shadow-md p-6 mb-6 overflow-hidden">
            <div class="overflow-x-auto">
                <table id="result-table" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th data-translate-key="tableHeaderIndex" class="table-header w-1/6">序号</th>
                            <th data-translate-key="tableHeaderQuestion" class="table-header w-2/6">问题</th>
                            <th data-translate-key="tableHeaderAnswer" class="table-header w-3/6">答案</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
        </div>

        <div id="no-data-message" class="hidden text-danger mt-4 flex items-center">
            <i class="fa-solid fa-exclamation-circle mr-2"></i>
            <span data-translate-key="noDataToExport">没有数据可供导出。</span>
        </div>
    </div>

    <script>
        // 全局变量
        let datasetId = "";
        let documentId = "";
        let totalChunks = 0;
        let questionIndex = 0;
        let currentChunk = 0;
        let isGenerating = false;
        let activeDatasetId = "";      // 当前数据集ID
        let activeQaDatasetId = "";    // 当前QA数据集ID
        let activeQaDocumentId = "";   // 当前QA文档ID
        let activeDocumentIds = [];    // 当前文档ID列表
        let globalRowIndex = 1;        // 全局行索引（表格序号）
        let currentPage = 1;
        let documentIndex = 0;
        // 全局变量（现有基础上新增）
        let savedProgress = null; // 保存的进度数据
        let excludedQuestions = "";
        let generationRequirements = "";
        let client_name = "";
        // 生成要求文本（中英文对照）
        const generationRequirementsTexts = {
    'Chinese Simplified': `1. **提问规则**：
   - 完全避开目录相关内容，不针对章节名称、目录格式等提问；
   - 围绕文档中的关键信息（如数据、利率、产品、标准、政策、规范、流程、步骤、概念、方法、技巧、差异等）提问，问题必须与客户在实际场景中可能产生的疑惑、需求、文档中的产品紧密相关，避免提出无关问题，问题必须是文档片段内容能回答的，不能回答的问题不要提；
   - 用自然语言表述，句式可以是一般疑问句、特殊疑问句等，问题要清晰明确，符合客户或用户的提问习惯。

2. **答案要求**：
   - 答案内容必须完全来源于文档片段，禁止杜撰任何信息，确保每个答案都能在文档中找到确切依据；
   - 若答案包含多个要点，需分点详细说明，每个要点要展开具体内容，保证内容完整充实，答案字数控制在30 - 150字之间；

3. **数量限制**：每个文档片段生成的问答对在20-40个之间，且问答对要尽可能全面地覆盖文档中的重要知识点。`,
    'English': `1. **Questioning Rules**:  
   - Completely avoid content related to the table of contents, such as chapter names or table of contents formats.  
   - Focus on key information in the document (e.g., data, interest rates, products, standards, policies, specifications, processes, steps, concepts, methods, techniques, differences), and pose questions closely related to real-world customer doubts, needs, or products. Questions must be answerable by the document fragment—do not ask irrelevant questions.  
   - Use natural language in the form of general or special questions, ensuring clarity and consistency with customer/user questioning habits.  

2. **Answer Requirements**:  
   - Answers must be derived entirely from the document fragment; no fabricated information is allowed. Ensure each answer has explicit evidence in the document.  
   - If an answer includes multiple points, elaborate on each point separately with specific details. Keep the answer concise, between 30–150 words.  

3. **Quantity Limit**:  
   Generate 20–40 Q&A pairs for each document fragment, aiming to comprehensively cover important knowledge points in the document.`
};
        // 进度数据格式
        const PROGRESS_KEY = "qa_task_progress"; // 本地存储键名
        // 全局变量（模块级作用域）
        let estimatedRemainingTime = 0;
        let processingTimes = [];  // 记录分块处理时间

        // 取消按钮
        document.getElementById('cancel-button').addEventListener('click', function () {
            // 使用微任务确保UI更新优先
            queueMicrotask(() => {
                cancelGeneration();
            });
        });

        function validateProgressData(progress) {
            const requiredFields = [
                'clientId', 'businessId', 'productId',
                'datasetId', 'qaDatasetId', 'documentIds'
            ];

            for (const field of requiredFields) {
                if (!progress[field]) {
                    throw new Error(`进度数据不完整：缺少${field}`);
                }
            }

            return true;
        }

        function resetTableAndState() {
            // 1. 清空表格
            resultTableBody.innerHTML = "";
            
            // 2. 重置核心计数器和索引
            globalRowIndex = 1;
            questionIndex = 0;
            documentIndex = 0;
            currentChunk = 0;
            currentPage = 1;
            totalChunks = 0;
            
            // 3. 重置ID和数据集相关参数
            datasetId = "";
            documentId = "";
            activeDatasetId = "";
            activeQaDatasetId = "";
            activeQaDocumentId = "";
            activeDocumentIds = [];
            
            // 4. 重置任务状态
            isGenerating = false;
            savedProgress = null;
            
            // 5. 重置生成选项和要求
            excludedQuestions = "";
            generationRequirements = "";

            tableData = null;
            
            // 7. 清除本地存储的进度
            localStorage.removeItem(PROGRESS_KEY);
            
            // 8. 额外清理：停止任何正在进行的API请求
            if (window.currentAbortController) {
                window.currentAbortController.abort();
                window.currentAbortController = null;
            }
            
            console.log("任务已完全重置：所有参数恢复到初始状态");
        }

        // 取消生成函数
        function cancelGeneration() {
            if (!isGenerating) {
                updateStatus('任务未在运行中，无需取消', 'info');
                return;
            }

            isGenerating = false;

            // 获取当前表格内容
            const tableBody = document.getElementById("result-table").querySelector("tbody");
            // 保存表格数据（包括序号）
            const tableData = Array.from(tableBody.rows).map(row => ({
                index: parseInt(row.cells[0].textContent), // 保存原有序号
                question: row.cells[1].textContent,
                answer: row.cells[2].textContent
            }));



            // 保存进度到本地存储（使用全局变量）
            const progress = {
                isTaskA: document.getElementById("task-type-a").checked,
                clientId: document.getElementById("client-id").value,
                businessId: document.getElementById("business-select").value,
                productId: document.getElementById("product-select").value,
                documentLanguage: document.getElementById("document-language").value,
                isClearHistory: document.getElementById("clear-history").checked,
                questionIndex: questionIndex,
                currentChunk: currentChunk,
                documentIndex: documentIndex,
                page: currentPage,
                globalRowIndex: globalRowIndex,
                tableData: tableData, // 保存表格内容
                datasetId: activeDatasetId,          // 使用全局变量
                qaDatasetId: activeQaDatasetId,      // 使用全局变量
                qaDocumentId: activeQaDocumentId,    // 使用全局变量
                documentIds: activeDocumentIds,      // 保存文档ID列表
                totalChunks: totalChunks,
                excludedQuestions: excludedQuestions,
                generationRequirements: generationRequirements,
                createdTime: new Date().getTime()
            };

            localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));

            updateStatus('任务已暂停，进度已保存', 'warning');
            document.getElementById('progress-container').classList.add('hidden');

            // 隐藏取消按钮
            document.getElementById('cancel-button').classList.add('hidden');
            document.getElementById('generate-button').disabled = false;
            document.getElementById('cancel-button').disabled = true;
        }

        // 初始化进度条
        function initProgress(isTaskA, total, initialChunk = 0) {
            totalChunks = total;
            currentChunk = initialChunk; // 新增：设置初始进度
            
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            progressContainer.classList.remove('hidden');
            
            // 计算并设置初始进度百分比
            const percentage = total > 0 ? Math.min(100, (initialChunk / total) * 100) : 0;
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);

            // 设置任务类型文本
            const taskName = isTaskA ? '查找答案' : '生成问答';
            if (progressText) {
                progressText.textContent = `任务: ${taskName} | 进度: ${initialChunk}/${total}`;
            }
        }

        // 完成进度
        function finishProgress(isTaskA, success = true) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            // 确保进度条达到100%
            progressBar.style.width = '100%';

            // 更新完成状态
            const taskName = isTaskA ? '查找答案' : '生成问答';
            if (progressText) {
                progressText.textContent = `任务: ${taskName} | 状态: ${success ? '完成' : '失败'}`;
            }

            // 添加完成动画
            const statusClass = success ? 'bg-green-500' : 'bg-red-500';
            progressBar.classList.add(statusClass);

            setTimeout(() => {
                progressBar.classList.remove(statusClass);
            }, 2000);

            localStorage.removeItem(PROGRESS_KEY); // 清除已完成的进度
            // 隐藏取消按钮
            document.getElementById('cancel-button').classList.add('hidden');
            document.getElementById('generate-button').disabled = false;
        }

        // 通过知识库名称获取datasetId
        async function getDatasetId(knowledgeName) {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            let datasetId = null;
            let currentPage = 1;
            let hasMore = true;

            try {
                // 循环遍历所有页直到找到匹配项或没有更多数据
                while (hasMore && !datasetId) {
                    const response = await fetch(`/api/datasets?page=${currentPage}`);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log("getDatasetId:", result);
                    const data = result.data;

                    // 在当前页中查找匹配的数据集
                    const dataset = data.data.find(d => d.name === knowledgeName);
                    if (dataset) {
                        datasetId = dataset.id;
                        break;
                    }

                    // 更新分页状态
                    hasMore = data.has_more;
                    currentPage++;
                }

                if (!datasetId) {
                    console.warn(`未找到名称为 "${knowledgeName}" 的数据集`);
                }

                return datasetId;

            } catch (error) {
                console.error('获取datasetId失败:', error);
                return null;
            }
        }

        // 获取数据集下的所有文档（遍历所有分页）
        async function getDocumentIds(datasetId) {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            let allDocumentIds = [];
            let currentPage = 1;
            let hasMore = true;

            try {
                // 循环遍历所有分页直到没有更多数据
                while (hasMore) {
                    const response = await fetch(`/api/datasets/${datasetId}/documents?page=${currentPage}`);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log('getDocuments:', result);
                    const documentIds = result.data.map(item => item.id);
                    console.log('documentIds:', documentIds);
                    // 累加当前页的文档
                    allDocumentIds = [...allDocumentIds, ...documentIds];
                    console.log('allDocumentIds:', allDocumentIds);
                    // 更新分页状态
                    hasMore = result.has_more;
                    currentPage++;
                }
                // 更新全局文档ID列表
                activeDocumentIds = allDocumentIds;
                return allDocumentIds;

            } catch (error) {
                console.error('获取文档列表失败:', error);
                return [];
            }
        }

        // 获取分段数据
        async function getChunks(datasetId, documentId, currentPage = 1) {
            const response = await fetch(`/api/datasets/${datasetId}/documents/${documentId}/segments?page=${currentPage}`, {
                method: "GET",
                headers: { "Content-Type": "application/json" }
            });

            if (!response.ok) {
                throw new Error(`获取文档分段失败: ${response.status}`);
            }

            const result = await response.json();

            console.log('result:', result);
            return {
                chunks: result.data,         // 文档分段数据
                total: result.total,         // 总记录数
                page: result.page,           // 当前页码
                limit: result.limit,         // 每页数量
                hasMore: result.has_more     // 是否有更多数据
            };
        }

        // 存储业务和产品数据
        let businessData = [];
        let productData = [];
        let clientIdData = [];

        // 获取 Client ID 数据
        function fetchClientIds() {
            const statusDiv = document.getElementById("status");
            statusDiv.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-3 text-primary"></i><span>正在获取Client ID列表...</span>';
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            // 直接调用API获取Client ID数据
            fetch('/user/client_id',
                {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json",
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    clientIdData = data;
                    renderClientIdSelect();
                    // 更新状态
                    statusDiv.innerHTML = '<i class="fa-solid fa-check-circle mr-3 text-accent"></i><span>Client ID列表已加载</span>';
                })
                .catch(error => {
                    console.error('Error fetching client IDs:', error);
                    statusDiv.innerHTML = `<i class="fa-solid fa-exclamation-circle mr-3 text-danger"></i><span>获取Client ID失败: ${error.message}</span>`;
                });
        }

        // 渲染Client ID选择框
        function renderClientIdSelect() {
            const clientIdSelect = document.getElementById("client-id");

            // 清空现有选项
            clientIdSelect.innerHTML = '<option value="">-- 请选择租户 --</option>';

            // 添加Client ID选项
            clientIdData.forEach(client => {
                const option = document.createElement('option');
                option.value = client.id;
                option.textContent = `${client.name} (${client.id})`;
                client_name = client.name;
                clientIdSelect.appendChild(option);
            });

            // 默认选择第一个有效选项（跳过占位符）
            if (clientIdSelect.options.length > 1) {
                clientIdSelect.options[1].selected = true; // 索引0为占位符，索引1为第一个有效选项
            }
        }

        // 获取业务数据
        function fetchBusinessData() {
            const statusDiv = document.getElementById("status");
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            statusDiv.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-3 text-primary"></i><span>正在获取业务列表...</span>';

            // 直接调用API获取业务数据
            fetch('/user/biz/product',
                {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json",
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    businessData = data;
                    renderBusinessSelect();
                    // 更新状态
                    statusDiv.innerHTML = '<i class="fa-solid fa-check-circle mr-3 text-accent"></i><span>业务列表已加载</span>';
                })
                .catch(error => {
                    console.error('Error fetching business data:', error);
                    statusDiv.innerHTML = `<i class="fa-solid fa-exclamation-circle mr-3 text-danger"></i><span>获取业务数据失败: ${error.message}</span>`;
                });
        }

        // 渲染业务选择下拉框
        function renderBusinessSelect() {
            const businessSelect = document.getElementById("business-select");

            // 清空现有选项
            businessSelect.innerHTML = '<option value="">-- 请选择业务 --</option>';

            // 添加业务选项
            businessData.forEach(business => {
                productData = business.products;
                const option = document.createElement('option');
                option.value = business.businessId;
                option.textContent = `${business.businessName} (${business.businessId})`;
                businessSelect.appendChild(option);
            });

            // 默认选择第一个有效选项（跳过占位符）
            if (businessSelect.options.length > 1) {
                businessSelect.options[1].selected = true; // 索引0为占位符，索引1为第一个有效选项
            }
            onBusinessSelectChange();
        }

        // 业务选择变更事件处理
        function onBusinessSelectChange() {
            const productSelect = document.getElementById("product-select");

            // 清空产品选择框
            productSelect.innerHTML = '<option value="">-- 请选择产品 --</option>';

            if (productData) {
                // 添加产品选项
                productData.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product.id;
                    option.textContent = `${product.name} (${product.id})`;
                    productSelect.appendChild(option);
                });
            }

            // 默认选择第一个有效选项（跳过占位符）
            if (productSelect.options.length > 1) {
                productSelect.options[1].selected = true; // 索引0为占位符，索引1为第一个有效选项
            }
        }
        // 清除所有错误提示
        function clearAllErrors() {
            const errorElements = document.querySelectorAll('.error-message');
            errorElements.forEach(element => {
                element.classList.add('hidden');
            });

            const inputElements = document.querySelectorAll('input, select');
            inputElements.forEach(element => {
                element.classList.remove('input-error');
            });
        }

        // 显示错误提示
        function showError(elementId, message) {
            const errorElement = document.getElementById(elementId);
            const inputElement = document.getElementById(elementId.replace('-error', ''));

            if (errorElement && inputElement) {
                errorElement.querySelector('span').textContent = message;
                errorElement.classList.remove('hidden');
                inputElement.classList.add('input-error');
            }
        }

        // 更新状态显示
        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById("status");
             
            let icon, color;
            
            switch(type) {
                case 'loading':
                    icon = '<i class="fa-solid fa-spinner fa-spin mr-3"></i>';
                    color = 'text-primary';
                    break;
                case 'success':
                    icon = '<i class="fa-solid fa-check-circle mr-3"></i>';
                    color = 'text-accent';
                    break;
                case 'error':
                    icon = '<i class="fa-solid fa-exclamation-circle mr-3"></i>';
                    color = 'text-danger';
                    break;
                case 'canceling':
                    icon = '<i class="fa-solid fa-spinner fa-spin mr-3"></i>';
                    color = 'text-warning';
                    break;
                case 'canceled':
                    icon = '<i class="fa-solid fa-ban mr-3"></i>';
                    color = 'text-warning';
                    break;
                default:
                    icon = '<i class="fa-solid fa-info-circle mr-3"></i>';
                    color = 'text-gray-600';
            }
            
            statusDiv.innerHTML = `<span class="${color}">${icon}</span><span>${message}</span>`;
 
        }

        function toggleQuestionUpload() {
            const isTaskA = document.getElementById("task-type-a").checked;
            const questionUpload = document.getElementById("question-list-upload");
            const requirementsBox = document.getElementById("requirements-box");
            if (isTaskA) {
                questionUpload.classList.remove("hidden");
                requirementsBox.classList.add("hidden");
            } else {
                questionUpload.classList.add("hidden");
                requirementsBox.classList.remove("hidden");
            }
        }

        // 添加输入框焦点事件处理
        document.addEventListener("DOMContentLoaded", () => {
            // 绑定事件处理函数
            document.getElementById("business-select").addEventListener("change", onBusinessSelectChange);
            // 隐藏问题列表上传（默认不选任务类型a）
            document.getElementById("question-list-upload").classList.add("hidden");
            // 绑定任务类型切换事件
            document.getElementById("task-type-a").addEventListener("change", toggleQuestionUpload);
            // 初始化业务数据和Client ID数据

            fetchClientIds();
            fetchBusinessData();
            onBusinessSelectChange();

            // 新增：文档语言切换事件
            const languageSelect = document.getElementById("document-language");
            const requirementsTextarea = document.getElementById("generation-requirements");
            
            // 初始化生成要求文本
            updateGenerationRequirements();
            
            // 监听语言选择变化
            languageSelect.addEventListener("change", updateGenerationRequirements);
            
            function updateGenerationRequirements() {
                const selectedLanguage = languageSelect.value;
                if (generationRequirementsTexts[selectedLanguage]) {
                    requirementsTextarea.value = generationRequirementsTexts[selectedLanguage];
                    generationRequirements = requirementsTextarea.value; // 更新全局变量
                }
            }
            
            // 任务类型切换时同步更新生成要求（当从任务A切换到QA时）
            document.getElementById("task-type-a").addEventListener("change", () => {
                if (!document.getElementById("task-type-a").checked) {
                    updateGenerationRequirements(); // 非任务A时显示生成要求
                }
            });
        });

        document.getElementById("query-button").addEventListener("click", async () => {
            clearAllErrors();
            const clientId = document.getElementById("client-id").value;
            const businessId = document.getElementById("business-select").value;
            const productId = document.getElementById("product-select").value;
            const documentLanguage = document.getElementById("document-language").value;
            const resultTable = document.getElementById("result-table");
            const resultTableBody = resultTable.querySelector("tbody");
            const token = new URLSearchParams(window.location.search).get('token');

            // 验证是否选择了语言
            if (!documentLanguage) {
                updateStatus('请选择文档语言', 'error');
                showError('document-language-error', '请选择文档语言');
                return;
            }

            // 新增：验证租户、业务、产品是否选择
            if (!clientId) {
                updateStatus('请选择租户', 'error');
                showError('client-id-error', '请选择租户');
                return;
            }

            if (!businessId) {
                updateStatus('请选择业务', 'error');
                showError('business-select-error', '请选择业务');
                return;
            }

            if (!productId) {
                updateStatus('请选择产品', 'error');
                showError('product-select-error', '请选择产品');
                return;
            }

            //问答知识库名称
            const qaKnowledgeBaseName = `${client_name}-${productId}-qa`;
            updateStatus('正在查询知识库...', 'loading');
            resultTableBody.innerHTML = ""; // 清空表格

            try {
                // 1. 获取数据集 ID
                const datasetId = await getDatasetId(qaKnowledgeBaseName);
                activeDatasetId = datasetId;
                if (!datasetId) throw new Error('未找到对应的知识库');

                // 2. 获取所有文档 ID
                const documentIds = await getDocumentIds(datasetId);
                if (documentIds.length === 0) throw new Error('知识库中无文档');
                activeDocumentIds = documentIds;

                let rowIndex = 1; // 全局序号计数器

                // 3. 遍历文档获取分块数据并查询问答
                for (const documentId of documentIds) {

                    const { total } = await getChunks(datasetId, documentId, 1, 1); // 先获取总记录数
                    initProgress(true, total); // 初始化进度条（查询任务）


                    let currentPage = 1;
                    while (true) {
                        const { chunks, hasMore } = await getChunks(datasetId, documentId, currentPage);
                        if (chunks.length === 0) break;

                        for (const chunk of chunks) {
                            // 直接使用 chunk.content 和 chunk.answer 作为问答结果
                            const row = document.createElement("tr");
                            row.innerHTML = `
                                <td class="table-cell text-center">${rowIndex++}</td>
                                <td class="table-cell">${chunk.content}</td>
                                <td class="table-cell">${chunk.answer || '无答案'}</td>
                            `;
                            resultTableBody.appendChild(row);

                            currentChunk++;
                            updateProgress(true); // 更新进度
                            scrollToLatestPosition();
                        }

                        if (!hasMore) break;
                        currentPage++;
                    }
                }
                if (resultTableBody.children.length === 0) {
                    updateStatus('知识库中无有效问答数据', 'warning');
                } else {
                    updateStatus('查询完成', 'success');
                }

            } catch (error) {
                console.error('查询失败:', error);
                updateStatus(`查询失败: ${error.message}`, 'error');
                resultTableBody.innerHTML = "";
            } finally {
                finishProgress(true); // 结束进度条
            }
        });

        document.getElementById("create-button").addEventListener("click", async () => {
            clearAllErrors();

            // 新增：获取租户、业务、产品ID
            const clientId = document.getElementById("client-id").value;
            const businessId = document.getElementById("business-select").value;
            const productId = document.getElementById("product-select").value;
            const knowledgeBaseName = `${client_name}-${productId}`; // 原知识库名称
            const files = document.getElementById("file-upload").files;
            const documentLanguage = document.getElementById("document-language").value;

            // 验证是否上传了文件
            if (files.length === 0) {
                updateStatus('请上传 PDF 文件', 'error');
                showError('file-upload-error', '请上传 PDF 文件');
                return;
            }

            // 验证是否选择了语言
            if (!documentLanguage) {
                updateStatus('请选择文档语言', 'error');
                showError('document-language-error', '请选择文档语言');
                return;
            }

            // 新增：验证租户、业务、产品是否选择
            if (!clientId) {
                updateStatus('请选择租户', 'error');
                showError('client-id-error', '请选择租户');
                return;
            }

            if (!businessId) {
                updateStatus('请选择业务', 'error');
                showError('business-select-error', '请选择业务');
                return;
            }

            if (!productId) {
                updateStatus('请选择产品', 'error');
                showError('product-select-error', '请选择产品');
                return;
            }

            updateStatus('正在创建...', 'loading');

            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            // 上传所有文件并获取 upload_file_id 数组
            const uploadFileIds = await Promise.all(
                Array.from(files).map(file => uploadFile(file, token, clientId))
            );

            console.log('uploadFileIds:', uploadFileIds)

            // 检查是否有文件上传失败
            if (uploadFileIds.some(id => id === null)) {
                updateStatus('文件上传失败', 'error');
                return;
            }

            const requestBody = {
                inputs: {
                    knowledge_base_name: knowledgeBaseName,
                    doc_language: documentLanguage,
                    files: uploadFileIds.map(id => ({
                        type: "document",
                        transfer_method: "local_file",
                        upload_file_id: id
                    }))
                },
                response_mode: "streaming",
                user: clientId,
                token: token
            };

            console.log("Request body:", requestBody);

            fetch(`/api/qa/create_knowledge`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(requestBody)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    console.log('Received JSON:', jsonData);
                    dataArray = jsonData.split('\n\n');
                    // 提取结果
                    let results = [];
                    dataArray.forEach(data => {
                        if (data && data != "event: ping") {
                            dify_obj = JSON.parse(data.replace('data:', ""));
                            console.log('Received Each data:', dify_obj);
                            // 更新状态显示
                            if (dify_obj.event) {
                                updateStatus(`状态: ${dify_obj.event}`, 'loading');
                            }
                            if (dify_obj.event === "workflow_finished" && dify_obj.data && dify_obj.data.outputs) {
                                const outputArray = dify_obj.data.outputs;
                                console.log("Output array:", outputArray);
                                results = outputArray.result
                                console.log("results:", results);
                                if (results && results.length > 0 && results[0].message) {
                                    updateStatus(`状态：${results[0].message}`, 'success');
                                } else {
                                    updateStatus('生成完成', 'success');
                                }
                            }
                        }
                    });
                })
                .catch(err => {
                    console.error('Fetch error:', err);
                    updateStatus(`发生错误: ${err.message}`, 'error');
                });
        });

        // 上传文件的函数
        async function uploadFile(file, token, clientId){
            updateStatus(`正在上传文件: ${file.name}`, 'loading');

            const uploadUrl = `/api/files/upload_pdf`;

            const formData = new FormData();
            formData.append('file', file);
            formData.append('token', token);
            formData.append('user', clientId);

            try {
                const response = await fetch(uploadUrl, {
                    method: "POST",
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    updateStatus(`文件上传成功: ${file.name}`, 'success');
                    return data.id; // 返回 upload_file_id
                } else {
                    console.error("文件上传失败，状态码:", response.status);
                    updateStatus(`文件上传失败: ${file.name}`, 'error');
                    return null;
                }
            } catch (err) {
                console.error("文件上传错误:", err);
                updateStatus(`文件上传错误: ${file.name}`, 'error');
                return null;
            }
        }

        function isTableOfContents(content) {
            return content.indexOf(". . . ") > -1 || content.indexOf("...") > -1;
        }
        
        document.getElementById("generate-button").addEventListener("click", async () => {
            // 初始化时间跟踪变量
            const startTime = Date.now();
            let lastUpdateTime = startTime;
            processingTimes = [];
            window.lastAvgTime = null;
            
            clearAllErrors();
            const clientId = document.getElementById("client-id").value;
            const businessId = document.getElementById("business-select").value;
            const productId = document.getElementById("product-select").value;
            const isTaskA = document.getElementById("task-type-a").checked;
            const files = document.getElementById("question-file").files;
            const documentLanguage = document.getElementById("document-language").value;
            const isClearHistory = document.getElementById("clear-history").checked;
            const token = new URLSearchParams(window.location.search).get('token');
            const progressContainer = document.getElementById('progress-container');
            const resultTable = document.getElementById("result-table");
            const resultTableBody = resultTable.querySelector("tbody");
            generationRequirements = document.getElementById("generation-requirements").value;
            const selectedMethod = document.querySelector('input[name="generation-method"]:checked').value;
            resultTableBody.innerHTML = "";

            // 验证是否选择了语言
            if (!documentLanguage) {
                updateStatus('请选择文档语言', 'error');
                showError('document-language-error', '请选择文档语言');
                return;
            }

            // 新增：验证租户、业务、产品是否选择
            if (!clientId) {
                updateStatus('请选择租户', 'error');
                showError('client-id-error', '请选择租户');
                return;
            }

            if (!businessId) {
                updateStatus('请选择业务', 'error');
                showError('business-select-error', '请选择业务');
                return;
            }

            // 验证产品ID
            if (!productId) {
                updateStatus('请选择产品', 'error');
                showError('product-select-error', '请选择产品');
                return;
            }

            if (isTaskA) {
                // 任务类型A：根据问题列表找答案
                if (files.length === 0) {
                    updateStatus('请上传xlsx格式的问题列表文', 'error');
                    showError('question-file-error', '请上传xlsx格式的问题列表文件');
                    return;
                }
            }

            if (!selectedMethod) {
                updateStatus('请选择生成方式', 'error');
                showError('generation-method-error', '请选择生成方式');
                return;
            }

            // 显示取消按钮
            document.getElementById('cancel-button').classList.remove('hidden');
            document.getElementById('cancel-button').disabled = false;
            this.disabled = true;

            // **新增：检查是否有未完成的进度**
            const savedProgress = localStorage.getItem(PROGRESS_KEY);
            if (savedProgress) {
                const confirmResume = confirm('检测到未完成的任务，是否恢复进度？');
                if (confirmResume) {
                    // 解析并应用保存的进度
                    const progress = JSON.parse(savedProgress);
                    validateProgressData(progress);
                    Object.assign(this, progress); // 将进度数据合并到当前作用域
                    isGenerating = true;
                    /// 恢复界面状态
                    document.getElementById("task-type-a").checked = progress.isTaskA;
                    document.getElementById("client-id").value = progress.clientId;
                    document.getElementById("business-select").value = progress.businessId;
                    document.getElementById("product-select").value = progress.productId;
                    document.getElementById("document-language").value = progress.documentLanguage;
                    document.getElementById("clear-history").value = progress.isClearHistory;

                    // 恢复进度条和状态
                    initProgress(progress.isTaskA, progress.totalChunks);
                    currentChunk = progress.currentChunk || 0;
                    updateProgress(progress.isTaskA);

                    // 根据任务类型恢复处理
                    if (progress.isTaskA) {
                        await resumeTaskA(progress);
                    } else {
                        await resumeTaskQA(progress);
                    }
                    return;
                } else {
                    // 清除过期进度
                    localStorage.removeItem(PROGRESS_KEY);
                }
            }

            //设置开始生成
            isGenerating = true;
            const knowledgeBaseName = `${client_name}-${productId}`; // 知识库名称
            // 问答知识库名称：产品ID + '-qa'
            const qaKnowledgeBaseName = `${client_name}-${productId}-qa`;
            updateStatus('正在创建问答知识库...', 'loading');

            try {
                // **创建知识库并获取关键ID**
                const { qa_dataset_id, qa_document_id, message } = await createQAKnowledgeBase(
                    qaKnowledgeBaseName,
                    documentLanguage,
                    isClearHistory,
                    token,
                    clientId
                );
                console.log(qa_dataset_id, qa_document_id, message)
                // 获取普通dataset_id
                const dataset_id = await getDatasetId(knowledgeBaseName); 
                activeDatasetId = dataset_id;
                console.log('dataset_id:', dataset_id)
                
                // **新增：计算全局总分块数**
                const document_ids = await getDocumentIds(dataset_id) || [];
                let totalGlobalChunks = 0;
                for (const documentId of document_ids) {
                    const { total } = await getChunks(dataset_id, documentId, 1);
                    totalGlobalChunks += total;
                }
                
                // **初始化全局进度条**
                initProgress(false, totalGlobalChunks);
                globalRowIndex = 1; // 重置表格序号
                
                // **根据任务类型处理**
                if (isTaskA) {
                    // 任务类型A：根据问题列表找答案
                    questionFile = files[0];
                    console.log('xlsx文件名：', questionFile.name);
                    const questions = await parseXlsx(questionFile);
                    console.log("questions:", questions)
                    // 检查是否有标题行（第一行）
                    const hasTitle = shouldExcludeFirstRowAsTitle(questions); // 自定义判断逻辑
                    const totalQuestions = hasTitle ? questions.length - 1 : questions.length;

                    initProgress(true, totalQuestions); // 初始化进度条（排除标题行）
                    let globalRowIndex = 1; // 全局序号计数器
                    
                    // 记录任务A开始时间
                    const taskAStartTime = Date.now();
                    
                    for (let i = 0; i < totalQuestions; i++) {
                        // 记录当前问题开始时间
                        const questionStartTime = Date.now();
                        
                        // 检查是否已取消
                        if (!isGenerating) throw new Error("用户取消操作");

                        // 计算实际问题索引（如果有标题行，从1开始；否则从0开始）
                        questionIndex = hasTitle ? i + 1 : i;
                        const question = questions[questionIndex].trim();

                        console.log(`处理问题 ${i + 1}/${totalQuestions} (索引: ${questionIndex}):`, question);

                        if (!question) {
                            console.log("跳过空问题");
                            continue;
                        }

                        const results = await processAnswerFinding(
                            question,
                            documentLanguage,
                            dataset_id,
                            qa_dataset_id,
                            qa_document_id,
                            token,
                            clientId
                        );

                        // 处理多条结果
                        results.forEach((result, index) => {
                            if (!isGenerating) return; // 防止继续添加结果
                            // 为同一问题的多个答案添加序号
                            const displayQuestion = index > 0 ? `${question} (答案 ${index + 1})` : question;
                            // 添加序号（全局序号 + 答案序号）
                            const row = document.createElement("tr");
                            row.innerHTML = `
                                <td class="table-cell text-center">${globalRowIndex++}</td>
                                <td class="table-cell">${displayQuestion}</td>
                                <td class="table-cell">${result.answer || "未找到答案"}</td>
                            `;
                            resultTableBody.appendChild(row);
                        });

                        currentChunk = i + 1;
                        
                        // 记录问题处理时间
                        const questionProcessTime = Date.now() - questionStartTime;
                        processingTimes.push(questionProcessTime);
                        if (processingTimes.length > 30) processingTimes.shift();
                        
                        // 更新剩余时间预估
                        updateRemainingTimeEstimate(isTaskA);
                        
                        updateProgress(true); // 更新进度（查找答案任务）
                        scrollToLatestPosition();
                    }

                } else {
                    // 任务类型QA：生成问答对
                    let globalRowIndex = 1; // 全局序号计数器
                    
                    // 记录任务QA开始时间
                    const taskQAStartTime = Date.now();
                    
                    for (const documentId of document_ids) {
                        documentIndex = document_ids.indexOf(documentId);
                        const { total } = await getChunks(dataset_id, documentId, 1);
                        
                        // **处理当前文档的分块**
                        let currentPage = 1;
                        while (isGenerating) {
                            // 记录当前块开始时间
                            const chunkStartTime = Date.now();
                            
                            const { chunks, hasMore } = await getChunks(dataset_id, documentId, currentPage);

                            for (const chunk of chunks) {
                                if (!isGenerating) throw new Error("用户取消操作");
                                
                                const results = await processQAGeneration(
                                    chunk.content,
                                    documentLanguage,
                                    qa_dataset_id,
                                    qa_document_id,
                                    token,
                                    clientId,
                                    generationRequirements
                                );

                                // 更新排除列表
                                excludedQuestions = results.map(item => item.content).filter(Boolean);

                                results.forEach(result => {
                                    if (!isGenerating) return; // 防止继续添加结果
                                    // 添加序号
                                    const row = document.createElement("tr");
                                    row.innerHTML = `
                                        <td class="table-cell text-center">${globalRowIndex++}</td>
                                        <td class="table-cell">${result.content || "未生成问题"}</td>
                                        <td class="table-cell">${result.answer || "未生成答案"}</td>
                                    `;
                                    resultTableBody.appendChild(row);
                                });
                                
                                currentChunk++; 
                                
                                // 记录块处理时间
                                const chunkProcessTime = Date.now() - chunkStartTime;
                                processingTimes.push(chunkProcessTime);
                                if (processingTimes.length > 30) processingTimes.shift();
                                
                                // 更新剩余时间预估
                                updateRemainingTimeEstimate(isTaskA);
                                
                                updateProgress(isTaskA); // 更新全局进度
                                scrollToLatestPosition();
                            }

                            if (!hasMore) break; // 没有更多数据时退出循环
                            currentPage++;
                        }
                    }
                }

                if (isGenerating) { // 确认操作完成时状态未被取消
                    finishProgress(isTaskA, true); // 完成进度（根据任务类型和全局处理数）
                }

            } catch (error) {
                if (isGenerating) { // 只处理非取消的错误
                    updateStatus(`操作失败: ${error.message}`, 'error');
                    finishProgress(isTaskA, false); // 标记为失败
                }
            } finally {
                isGenerating = false;
            }
        });

        async function resumeTaskA(progress) {
            updateStatus('正在恢复任务：根据问题找答案', 'loading');
            const token = new URLSearchParams(window.location.search).get('token');
            const resultTableBody = document.getElementById("result-table").querySelector("tbody");
            resultTableBody.innerHTML = "";

            // 初始化处理时间记录（避免与其他任务冲突）
            processingTimes = [];
            
            // **修复：手动赋值全局变量**
            isGenerating = true; // 全局变量
            activeDatasetId = progress.datasetId; // 数据集ID
            activeQaDatasetId = progress.qaDatasetId; // QA数据集ID
            activeQaDocumentId = progress.qaDocumentId; // QA文档ID
            currentChunk = progress.currentChunk || 0; // 当前处理问题索引
            totalChunks = progress.totalChunks || 1; // 总问题数
            globalRowIndex = progress.globalRowIndex || 1; // 全局序号

            // 修复：使用保存的currentChunk初始化进度条
            initProgress(true, progress.totalChunks, progress.currentChunk || 0);
            updateProgress(true); // 立即更新进度显示

            try {
                // 重建表格数据（包含正确序号）
                if (progress.tableData && progress.tableData.length > 0) {
                    progress.tableData.forEach(item => {
                        const row = document.createElement("tr");
                        row.innerHTML = `
                            <td class="table-cell text-center">${item.index}</td>
                            <td class="table-cell">${item.question}</td>
                            <td class="table-cell">${item.answer}</td>
                        `;
                        resultTableBody.appendChild(row);
                    });
                    // 下一个序号从最后一个序号+1开始
                    globalRowIndex = progress.tableData.length > 0 
                        ? Math.max(...progress.tableData.map(item => item.index)) + 1 
                        : 1;
                } else {
                    globalRowIndex = 1;
                }

                // 重新获取问题文件（确保文件存在）
                const questionFile = document.getElementById("question-file").files[0];
                if (!questionFile) throw new Error('未找到问题文件，请重新选择');

                // 解析问题列表
                const questions = await parseXlsx(questionFile);
                const hasTitle = shouldExcludeFirstRowAsTitle(questions);
                const totalQuestions = hasTitle ? questions.length - 1 : questions.length;

                // 从保存的索引开始处理问题
                const startIndex = progress.questionIndex || 0;
                
                // **新增：计算实际总分块数并初始化进度**
                totalChunks = totalQuestions;
                initProgress(true, totalChunks, startIndex);
                updateProgress(true);

                for (let i = startIndex; i < totalQuestions; i++) {
                    if (!isGenerating) throw new Error("用户取消操作");

                    const questionIndex = hasTitle ? i + 1 : i;
                    const question = questions[questionIndex].trim();

                    if (!question) continue;

                    // 记录问题处理开始时间
                    const questionStartTime = Date.now();
                    
                    const results = await processAnswerFinding(
                        question,
                        progress.documentLanguage,
                        activeDatasetId, // 使用全局变量
                        activeQaDatasetId, // 使用全局变量
                        activeQaDocumentId, // 使用全局变量
                        token,
                        progress.clientId
                    );

                    // 添加结果到表格
                    results.forEach((result, index) => {
                        const displayQuestion = index > 0 ? `${question} (答案 ${index + 1})` : question;
                        const row = document.createElement("tr");
                        row.innerHTML = `
                            <td class="table-cell text-center">${globalRowIndex++}</td>
                            <td class="table-cell">${displayQuestion}</td>
                            <td class="table-cell">${result.answer || "未找到答案"}</td>
                        `;
                        resultTableBody.appendChild(row);
                    });

                    // 记录问题处理时间
                    const questionProcessTime = Date.now() - questionStartTime;
                    processingTimes.push(questionProcessTime);
                    if (processingTimes.length > 30) processingTimes.shift(); // 保持最近30条记录
                    
                    // 更新当前处理进度
                    currentChunk = i + 1;
                    
                    // **新增：更新剩余时间预估**
                    updateRemainingTimeEstimate(true);
                    
                    updateProgress(true);
                    scrollToLatestPosition();
                }

                finishProgress(true);
                updateStatus('任务恢复完成', 'success');
                localStorage.removeItem(PROGRESS_KEY);

            } catch (error) {
                updateStatus(`任务恢复失败: ${error.message}`, 'error');
                finishProgress(true, false);
                resetTableAndState();
            }
            // 显示取消按钮
            document.getElementById('cancel-button').classList.remove('hidden');
            document.getElementById('cancel-button').disabled = false;
        }

        async function resumeTaskQA(progress) {
            // 恢复任务核心状态
            isGenerating = true;
            currentChunk = progress.currentChunk || 0;
            globalRowIndex = progress.globalRowIndex || 1;
            excludedQuestions = progress.excludedQuestions || "";
            
            // 重置处理时间记录（避免历史数据干扰）
            processingTimes = [];
            
            // 恢复生成要求文本
            const requirementsTextarea = document.getElementById("generation-requirements");
            if (progress.generationRequirements) {
                requirementsTextarea.value = progress.generationRequirements;
            } else if (generationRequirementsTexts[progress.documentLanguage]) {
                requirementsTextarea.value = generationRequirementsTexts[progress.documentLanguage];
            }
            generationRequirements = requirementsTextarea.value;

            // 初始化进度条（使用保存的进度数据）
            initProgress(false, progress.totalChunks, progress.currentChunk || 0);
            updateProgress(false);
            
            const resultTableBody = document.getElementById("result-table").querySelector("tbody");
            resultTableBody.innerHTML = "";
            
            // 重建表格数据（保留历史处理结果）
            if (progress.tableData && progress.tableData.length > 0) {
                progress.tableData.forEach(item => {
                    const row = document.createElement("tr");
                    row.innerHTML = `
                        <td class="table-cell text-center">${item.index}</td>
                        <td class="table-cell">${item.question}</td>
                        <td class="table-cell">${item.answer}</td>
                    `;
                    resultTableBody.appendChild(row);
                });
                globalRowIndex = progress.tableData.length > 0 
                    ? Math.max(...progress.tableData.map(item => item.index)) + 1 
                    : 1;
            } else {
                globalRowIndex = 1;
            }

            const token = new URLSearchParams(window.location.search).get('token');
            try {
                // 获取最新的文档列表（可能已更新）
                const documentIds = await getDocumentIds(progress.datasetId);
                if (documentIds.length === 0) throw new Error('知识库中无文档数据');
                
                // 校验并修正文档索引
                const maxDocumentIndex = documentIds.length - 1;
                let startDocumentIndex = progress.documentIndex || 0;
                startDocumentIndex = Math.min(startDocumentIndex, maxDocumentIndex);
                
                updateStatus(`从文档 ${startDocumentIndex + 1}/${documentIds.length} 开始恢复`, 'loading');

                // 重新计算实际总分块数（可能因文档更新而变化）
                let actualTotalChunks = 0;
                for (let i = 0; i < documentIds.length; i++) {
                    const docChunks = await getChunks(progress.datasetId, documentIds[i], 1);
                    actualTotalChunks += docChunks.total;
                }
                
                // 同步总分块数（确保与实际一致）
                if (progress.totalChunks !== actualTotalChunks) {
                    console.log(`[进度恢复] 总分块数更新: 保存=${progress.totalChunks} → 实际=${actualTotalChunks}`);
                    progress.totalChunks = actualTotalChunks;
                    initProgress(false, progress.totalChunks, progress.currentChunk || 0);
                    updateProgress(false);
                }
                
                // 核心处理逻辑：按文档遍历分块
                for (let i = startDocumentIndex; i < documentIds.length && isGenerating; i++) {
                    const documentId = documentIds[i];
                    const docChunksInfo = await getChunks(progress.datasetId, documentId, 1);
                    const docTotalChunks = docChunksInfo.total;
                    const docLimit = docChunksInfo.limit; // 每页分块数
                    
                    updateStatus(`处理文档 ${i + 1}/${documentIds.length} (ID: ${documentId})`, 'loading');
                    
                    // 计算当前文档的起始分页（支持断点续传）
                    let currentPage = (i === startDocumentIndex) ? (progress.page || 1) : 1;
                    const maxPage = Math.ceil(docTotalChunks / docLimit);
                    currentPage = Math.min(currentPage, maxPage);
                    
                    let isFirstDoc = (i === startDocumentIndex);
                    let isFirstPage = (currentPage === (progress.page || 1));
                    
                    // 分页处理循环
                    while (isGenerating && currentPage <= maxPage) {
                        const { chunks, hasMore } = await getChunks(progress.datasetId, documentId, currentPage);
                        
                        // 分块处理循环
                        for (let j = 0; j < chunks.length && isGenerating; j++) {
                            const chunk = chunks[j];
                            
                            // 精确计算全局分块索引（关键去重逻辑）
                            let currentChunkIndex = 0;
                            for (let k = 0; k < i; k++) {
                                const prevDocChunks = await getChunks(progress.datasetId, documentIds[k], 1);
                                currentChunkIndex += prevDocChunks.total;
                            }
                            currentChunkIndex += (currentPage - 1) * docLimit + j;
                            
                            // 智能跳过已处理分块（核心修复点）
                            if (currentChunkIndex < (progress.currentChunk || 0)) {
                                console.log(`[进度恢复] 跳过已处理分块: ${currentChunkIndex}`);
                                continue;
                            }
                            
                            // 记录分块处理开始时间（用于性能分析）
                            const chunkStartTime = Date.now();
                            
                            // 生成问答对（核心业务逻辑）
                            const results = await processQAGeneration(
                                chunk.content,
                                progress.documentLanguage,
                                progress.qaDatasetId,
                                progress.qaDocumentId,
                                token,
                                progress.clientId,
                                generationRequirements
                            );
                            
                            // 添加结果到表格
                            results.forEach(result => {
                                if (!isGenerating) return;
                                const row = document.createElement("tr");
                                row.innerHTML = `
                                    <td class="table-cell text-center">${globalRowIndex++}</td>
                                    <td class="table-cell">${result.content || "未生成问题"}</td>
                                    <td class="table-cell">${result.answer || "未生成答案"}</td>
                                `;
                                resultTableBody.appendChild(row);
                            });

                            // 安全更新进度计数（防止超过总分块数）
                            currentChunk = Math.min(currentChunk + 1, progress.totalChunks);
                            
                            // 记录分块处理时间（用于剩余时间预估）
                            const chunkProcessTime = Date.now() - chunkStartTime;
                            processingTimes.push(chunkProcessTime);
                            if (processingTimes.length > 30) processingTimes.shift(); // 保持最近30条记录
                            
                            // 更新剩余时间预估（关键功能点）
                            updateRemainingTimeEstimate(false);
                            
                            // 更新进度条显示（包含剩余时间）
                            updateProgress(false);
                            scrollToLatestPosition();
                        }
                        
                        if (!hasMore) break; // 无更多分块时退出
                        currentPage++;
                        isFirstPage = false;
                        
                        // 定期保存进度（每处理1页保存1次）
                        progress.documentIndex = i;
                        progress.page = currentPage;
                        progress.globalRowIndex = globalRowIndex;
                        progress.currentChunk = currentChunk;
                        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));
                    }
                }

                // 任务完成处理
                finishProgress(true);
                updateStatus('任务恢复完成', 'success');
                localStorage.removeItem(PROGRESS_KEY);

            } catch (error) {
                updateStatus(`任务恢复失败: ${error.message}`, 'error');
                console.error('[任务恢复错误]', error);
                finishProgress(true, false);
                resetTableAndState();
            } finally {
                // 恢复界面交互状态
                document.getElementById('cancel-button').classList.remove('hidden');
                document.getElementById('cancel-button').disabled = false;
                isGenerating = false;
            }
        }

        function updateRemainingTimeEstimate(isTaskA) {
            if (processingTimes.length === 0 || currentChunk >= totalChunks) {
                estimatedRemainingTime = 0;
                return;
            }
            
            // 计算移动平均处理时间
            const alpha = 0.6;
            let avgTime = processingTimes.reduce((sum, t) => sum + t, 0) / processingTimes.length;
            if (window.lastAvgTime) avgTime = alpha * avgTime + (1 - alpha) * window.lastAvgTime;
            window.lastAvgTime = avgTime;
            
            // 计算剩余时间
            const remainingChunks = totalChunks - currentChunk;
            estimatedRemainingTime = Math.max(0, remainingChunks * avgTime);
        }

        // 进度条更新函数（包含剩余时间显示）
        function updateProgress(isTaskA) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            if (!progressBar || !progressText) return;
            
            // 安全处理边界情况
            if (totalChunks <= 0) totalChunks = 1;
            currentChunk = Math.min(currentChunk, totalChunks);
            
            // 计算进度百分比
            const percentage = (currentChunk / totalChunks) * 100;
            const displayPercentage = Math.min(100, percentage);
            
            // 更新进度条样式
            progressBar.style.width = `${displayPercentage}%`;
            progressBar.setAttribute('aria-valuenow', displayPercentage);
            
            // 格式化剩余时间显示
            let timeEstimate = '';
            if (estimatedRemainingTime > 0 && currentChunk > 0) {
                timeEstimate = `，预计还需 ${formatTime(estimatedRemainingTime)}`;
            }

            // **新增：显示处理速度变化趋势**
            let speedTrend = '';
            if (processingTimes.length > 5) {
                const recentSpeed = processingTimes.slice(-5).reduce((sum, t) => sum + t, 0) / 5;
                const earlySpeed = processingTimes.slice(0, 5).reduce((sum, t) => sum + t, 0) / 5;
                const changePercent = ((recentSpeed - earlySpeed) / earlySpeed * 100).toFixed(0);
                
                if (recentSpeed > earlySpeed * 1.2) {
                    speedTrend = `（处理速度下降${changePercent}%）`;
                } else if (recentSpeed < earlySpeed * 0.8) {
                    speedTrend = `（处理速度提升${changePercent}%）`;
                }
            }
            
            // 更新进度文本（包含剩余时间和任务类型）
            const taskType = isTaskA ? '查找答案' : '生成问答';
            progressText.textContent = `任务: ${taskType} | 进度: ${currentChunk}/${totalChunks} (${displayPercentage.toFixed(0)}%)${timeEstimate}${speedTrend}`;
        }
        // 时间格式化工具函数（全局）
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}小时${minutes}分${seconds}秒`;
            } else if (minutes > 0) {
                return `${minutes}分${seconds}秒`;
            } else {
                return `${seconds}秒`;
            }
        }

        // 创建QA知识库并返回关键ID
        async function createQAKnowledgeBase(knowledgeBaseName, documentLanguage, isClearHistory, token, clientId) {
            updateStatus('正在创建问答知识库...', 'loading');

            const requestBody = {
                inputs: {
                    doc_language: documentLanguage,
                    qa_knowledge_name: knowledgeBaseName,
                    clear_history: isClearHistory ? "是" : "否"
                },
                response_mode: "streaming",
                user: clientId,
                token: token
            };

            try {
                const response = await fetch(`/api/qa/create_qa_knowledge`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const jsonData = await response.json();
                const dataArray = jsonData.split('\n\n');

                let workflowResult = null;
                dataArray.forEach(data => {
                    if (data && data !== "event: ping") {
                        try {
                            const difyObj = JSON.parse(data.replace('data:', ""));
                            console.log('Received data:', difyObj);

                            if (difyObj.event) {
                                updateStatus(`状态: ${difyObj.event}`, 'loading');
                            }

                            if (difyObj.event === "workflow_finished" && difyObj.data) {
                                workflowResult = difyObj.data;
                            }
                        } catch (e) {
                            console.warn('解析响应失败:', e);
                        }
                    }
                });

                if (!workflowResult) {
                    throw new Error('无法获取工作流结果');
                }

                // 从workflowResult中提取关键ID和消息
                const { outputs } = workflowResult;
                if (!outputs || outputs.length === 0) {
                    throw new Error('工作流输出为空');
                }

                const { qa_dataset_id, qa_document_id, message } = outputs;

                if (!qa_dataset_id || !qa_document_id) {
                    throw new Error(`创建知识库失败: ${message || '未返回有效ID'}`);
                }

                updateStatus(`状态: ${message || '知识库创建成功'}`, 'success');

                // 成功获取ID后更新全局变量
                activeQaDatasetId = qa_dataset_id;
                activeQaDocumentId = qa_document_id;
                return { qa_dataset_id, qa_document_id, message };

            } catch (error) {
                console.error('创建知识库失败:', error);
                updateStatus(`创建知识库失败: ${error.message}`, 'error');
                throw error; // 向上抛出错误
            }
        }

        // 根据问题查找答案（使用工作流处理，带重试逻辑）
        async function processAnswerFinding(question, language, datasetId, qaDatasetId, qaDocumentId, token, clientId, retryCount = 0) {
            updateStatus(`正在查找问题 "${question.substring(0, 60)}..." 的答案...`, 'loading');

            const requestBody = {
                inputs: {
                    doc_language: language,
                    query: question,
                    dataset_id: datasetId,
                    qa_dataset_id: qaDatasetId,
                    qa_document_id: qaDocumentId
                },
                response_mode: "streaming",
                user: clientId,
                token: token
            };

            try {
                const response = await fetch(`/api/qa/findAnswer`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const jsonData = await response.json();
                const dataArray = jsonData.split('\n\n');

                let workflowResult = null;
                dataArray.forEach(data => {
                    if (data && data !== "event: ping") {
                        try {
                            const difyObj = JSON.parse(data.replace('data:', ""));
                            console.log('Received data:', difyObj);

                            if (difyObj.event) {
                                updateStatus(`状态: ${difyObj.event}`, 'loading');
                            }

                            if (difyObj.event === "workflow_finished" && difyObj.data) {
                                workflowResult = difyObj.data;
                            }
                        } catch (e) {
                            console.warn('解析响应失败:', e);
                        }
                    }
                });

                if (!workflowResult) {
                    throw new Error('无法获取工作流结果');
                }

                const { outputs } = workflowResult;

                if (!outputs || !outputs.result) {
                    throw new Error('工作流输出格式不正确');
                }

                // 处理成功响应（支持数组或单个对象格式）
                const results = [];
                const resultItems = Array.isArray(outputs.result) ? outputs.result : [outputs.result];

                resultItems.forEach(item => {
                    if (item.status === 'success') {
                        // 提取实际答案数据
                        if (item.response && item.response.data && item.response.data.length > 0) {
                            const items = item.response.data.map(data => ({
                                question: question,
                                answer: data.answer || "未找到答案",
                                keywords: data.keywords?.join(", ") || "",
                                documentId: data.document_id,
                                content: data.content,
                                // 可根据需要提取更多字段
                            }));
                            results.push(...items);
                        }
                    } else if (item.status === 'failure') {
                        // 提取错误信息（支持嵌套格式）
                        let errorMessage = item.message || '未知错误';
                        if (item.response) {
                            try {
                                const responseObj = typeof item.response === 'string'
                                    ? JSON.parse(item.response)
                                    : item.response;
                                errorMessage = responseObj.message || errorMessage;
                            } catch (e) {
                                console.warn('解析错误响应失败:', e);
                            }
                        }
                        throw new Error(errorMessage);
                    }
                });

                if (results.length === 0) {
                    throw new Error('工作流返回空结果');
                }

                updateStatus(`找到 ${results.length} 个答案`, 'success');
                return results;

            } catch (error) {
                console.error('查找答案失败:', error);

                // 文档未完成时的重试逻辑（15秒后重试，最多3次）
                if (error.message.includes("Document is not completed") && retryCount < 5) {
                    // 显示准确的重试倒计时
                    updateStatus(`检测到问答知识库初始化未完成，请稍后，15秒后开始第${retryCount + 1}次重试...`, 'warning');

                    // 等待15秒后递归重试
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve(processAnswerFinding(
                                question,
                                language,
                                datasetId,
                                qaDatasetId,
                                qaDocumentId,
                                token,
                                clientId,
                                retryCount + 1
                            ));
                        }, 15000); // 15秒间隔
                    });
                } else {
                    updateStatus(`查找答案失败: ${error.message}`, 'error');
                    throw error;
                }
            }
        }

        // 生成问答对（使用工作流处理，带重试逻辑和章节检测）
        async function processQAGeneration(chunk, language, qaDatasetId, qaDocumentId, token, clientId, generationRequirements, retryCount = 0) {
            // 检测chunk是否包含章节信息
            if (isTableOfContents(chunk)) {
                setTimeout(() => {
                    updateStatus(`跳过包含目录信息的chunk: "${chunk.substring(0, 60)}..."`, 'info');
                }, 1000);
                return []; // 跳过处理，返回空数组
            }

            updateStatus(`正在生成关于 "${chunk.substring(0, 60)}..." 的问答...`, 'loading');

            const requestBody = {
                inputs: {
                    doc_language: language,
                    chunk: chunk,
                    qa_dataset_id: qaDatasetId,
                    qa_document_id: qaDocumentId,
                    generation_requirements: generationRequirements,
                    excluded_questions: excludedQuestions.toString()
                },
                response_mode: "streaming",
                user: clientId,
                token: token
            };

            try {
                const response = await fetch(`/api/qa/generate`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const jsonData = await response.json();
                const dataArray = jsonData.split('\n\n');

                let workflowResult = null;
                dataArray.forEach(data => {
                    if (data && data !== "event: ping") {
                        try {
                            const difyObj = JSON.parse(data.replace('data:', ""));
                            console.log('Received data:', difyObj);

                            if (difyObj.event) {
                                updateStatus(`状态: ${difyObj.event}`, 'loading');
                            }

                            if (difyObj.event === "workflow_finished" && difyObj.data) {
                                workflowResult = difyObj.data;
                            }
                        } catch (e) {
                            console.warn('解析响应失败:', e);
                        }
                    }
                });

                if (!workflowResult) {
                    throw new Error('无法获取工作流结果');
                }

                const { outputs } = workflowResult;

                if (!outputs || !outputs.result) {
                    throw new Error('工作流输出格式不正确');
                }

                // 处理输出结果（支持数组或单个对象格式）
                const results = [];
                const resultItems = Array.isArray(outputs.result) ? outputs.result : [outputs.result];

                resultItems.forEach(item => {
                    if (item.status === 'success') {
                        // 提取生成的问答对数据
                        if (item.response && item.response.data && item.response.data.length > 0) {
                            const items = item.response.data.map(data => ({
                                content: data.content || "未生成问题",
                                answer: data.answer || "未生成答案",
                            }));
                            results.push(...items);
                        }
                    } else if (item.status === 'failure') {
                        // 提取错误信息（支持嵌套格式）
                        let errorMessage = item.message || '未知错误';
                        if (item.response) {
                            try {
                                const responseObj = typeof item.response === 'string'
                                    ? JSON.parse(item.response)
                                    : item.response;
                                errorMessage = responseObj.message || errorMessage;
                            } catch (e) {
                                console.warn('解析错误响应失败:', e);
                            }
                        }
                        throw new Error(errorMessage);
                    }
                });

                if (results.length === 0) {
                    throw new Error('工作流返回空结果');
                }

                updateStatus(`生成 ${results.length} 组问答`, 'success');
                return results;

            } catch (error) {
                console.error('生成问答失败:', error);
                
                // 保留原有重试逻辑：文档未完成时重试，其他错误不重试
                if (error.message.includes("Document is not completed") && retryCount < 5) {
                    updateStatus(`检测到问答知识库初始化未完成，15秒后开始第${retryCount + 1}次重试...`, 'warning');
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve(processQAGeneration(
                                chunk,
                                language,
                                qaDatasetId,
                                qaDocumentId,
                                token,
                                clientId,
                                generationRequirements,
                                retryCount + 1
                            ));
                        }, 15000);
                    });
                } else {
                    updateStatus(`生成问答失败: ${error.message}`, 'error');
                    // 非文档未完成的错误，返回空数组不影响后续chunk
                    return [];
                }
            }
        }

        // XLSX文件解析函数
        function parseXlsx(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = e.target.result;
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    resolve(rows.flatMap(row => row.filter(cell => cell))); // 转换为单列数组
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function scrollToLatestPosition() {
            const container = document.getElementById('result-table-container');
            if (container) {
                // 使用scrollTo方法实现平滑滚动
                container.scrollTo({
                    top: container.scrollHeight,
                    behavior: 'smooth'
                });
            }
        }

        // 判断是否应排除第一行为标题
        function shouldExcludeFirstRowAsTitle(questions) {
            // 示例判断逻辑：检查第一行是否包含"标题"、"问题"等关键词
            const firstRow = questions[0]?.toLowerCase() || "";
            return firstRow.includes("question") || firstRow.includes("问题");
        }

        document.getElementById("export-csv-button").addEventListener("click", () => {
            const resultTable = document.getElementById("result-table");
            const rows = resultTable.querySelectorAll("tr");
            const csvContent = [];

            if (rows.length <= 1) {
                updateStatus('没有数据可供导出。', 'warning');
                document.getElementById("no-data-message").classList.remove("hidden");
                setTimeout(() => {
                    document.getElementById("no-data-message").classList.add("hidden");
                }, 3000);
                return;
            }

            updateStatus('正在准备CSV文件...', 'loading');

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll("td, th")); // 将 NodeList 转换为数组
                const rowContent = cells.map(cell => {
                    // 转义双引号
                    const cellText = cell.textContent.replace(/"/g, '""');
                    return `"${cellText}"`;
                }).join(",");
                csvContent.push(rowContent);
            });

            const csvString = csvContent.join("\n");
            const blob = new Blob([csvString], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "qa-results.csv");
                link.style.visibility = "hidden";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                updateStatus('CSV文件导出成功！', 'success');
            } else {
                updateStatus('导出失败，您的浏览器可能不支持此功能。', 'error');
            }
        });

    </script>
</body>
</html>